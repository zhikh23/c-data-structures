# c-data-structures

Библиотека обобщённых структур данных на языке программирования Си.

## Как использовать

Перед вставкой заголовочного файла с ОТД (читай далее), необходимо задать тип `T`.

```c++
#define T int
#include "vec.h"
#undef T

typedef void *pvoid;
#define T pvoid
#include "vec.h"
#undef T

int main(void) {
    vec_int_t *v_int = vec_int_create(0);
    vec_pvoid_t *v_pvoid = vec_pvoid_create(0);
    ...
}
```

Важно! `T` должно быть идентификатором типа данных (не указателем!).

## Описание заголовочных файлов

### Вспомогательные файлы

#### err.h

`err.h` содержит константы основных ошибок (см. таблицу ниже) и макросы для работы с ними через возвращаемые указатели.

| Название | Код  | Описание                | Пример                                                |
|:--------:|:----:|:------------------------|:------------------------------------------------------|
|  `EIO`   | `5`  | Ошибка ввода-вывода     | Ошибка открытия файла или некорректные данные в файле |
| `ENOMEM` | `12` | Ошибка выделения памяти | `malloc` вернул NULL                                  |
| `EINVAL` | `22` | Некорректные данные     | Нулевой размер матрицы                                |

#### generic.h

`generic.h` содержит макросы для создания псевдо-обобщённых типов данных (далее - ОТД).

Создание ОТД происходит в несколько этапов. Рассмотрим на примете ОТД массива (`arr`), где в качестве типа элемента
выступает макрос `T`.

##### Макрос идентификатора ОТД

```c++
#define ARR(type) GENERIC_TYPE(arr, type)
```

##### Создание типа ОТД

Через ключевое слово `typedef`:

```c++
typedef struct {
    size_t len;
    T      data[];
} ARR(T);
```

##### Создание структуры ОТД

Если необходимо создать структуру типа данных (`struct`), как, например, для реализации связанных списков,
используется макрос `GENERIC_STRUCT`:

```c++
#define NODE(type) GENERIC_TYPE(node, type)
#define NODE_STRUCT(type) GENERIC_STRUCT(node, type)
typedef NODE_STRUCT(T) {
    NODE_STRUCT(T) *next;
    T               data;
} NODE(T);
```

##### Использование макросов

Далее объявление объекта _ОТД_ без конкретного значения имеет вид:

```c++
ARR(T) *arr;
```

Вместо `T` подставляется конкретный тип и выражение преобразуется в:

```c++
// T = int
arr_int_t *arr;
```

> ВАЖНО! Для указания конкретного типа псевдо-обобщённого типа данных допускается использование только 
> **идентификаторов** типа.

Не допускается использование указателей, структур:

```c++
GENERIC_TYPE(arr, void*)   // -> arr_void*_t
```

Вместо этого необходимо объявить идентификатор-синоним типа:

```c++
typedef void *pvoid;
GENERIC_TYPE(arr, pvoid)   // -> arr_pvoid_t
```

##### Метод ОТД

Необходимо создать макрос идентификатора функции через `GENERIC_METHOD`.

```c++
#define ARR_PUSH(type) GENERIC_METHOD(arr, push, type)
```

Далее объявить функцию с данным макросом.

```c++
ARR(T) *ARR_PUSH(T) (ARR(T) *self, T value);
```

##### Вызов методов ОТД

Можно вызывать методы ОТД, используя тот же макрос.

```c++
ARR(T) *arr = ARR_CREATE(T) (0);
```

Обратите внимание: скобки указываются дважды. Первый раз - для вызова макроса, преобразующего ОТД в конкретный ТД, второй
раз - для непосредственно вызова функции.

### Список ОТД

- `vec_t` (`vec.h`) - вектор, саморасширяющийся динамический массив.

## Контакты

- [@zhikhkirill](https://t.me/zhikhkirill).
